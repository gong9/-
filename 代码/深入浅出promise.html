<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 所谓promise简单来说就是一个容器，里面保存着某个未来才会执行完的时间（通常是一个异步操作）的结果。从语法上说，promise是一个对象，从他身上可以获取异步操作的效益，promise提供统一的api，各种异步操作都可以通同样的方法进行处理
        // promise对象有两个特点：1对象的状态不受外界的影响，promise对象代表一个一步操作，有三种状态，运行中，已成功，已失败。只有异步操作的结构可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是promise名字的由来
        // 一旦状态改变就不会再改变，在任何时候都可以得到这个结果。promise对象的状态改变只有两种可能。从进行到成功，从进行到失败，它与事件完全不同的是

        //         promise构造函数接收一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数。这两个函数是有js引擎提供的不用我们部署
        //         resolve函数的作用是，将promise对象的状态从未成功改为已成功，在异步操作成功时调用。并将异步操作的结果作为参数传递出去，reject的作用是从进行时到失败，在异步操作失败的时候调用，将异步操作报出的错误最为参数传递出去
        //         promise实例生成之后可以用then方法指定可以用 then 方法分别指定 resolved 状态
        // 和 rejected 状态的回调函数。

        // iterator和for of循环
        // js原有的表示集合的数据结构，主要是数组和对象，es6又添加了map和set。这样就有了四种数据集合
        // iterator是一个借口，它为各种不同的数据结构提供了同一的访问机制。任何数据结构只要部署了iterator接口就可以完成遍历操作
        // iterator的作用有三个：一是为各种数据结构提供一个统一的简单的访问接口。二是使得数据结构的成员能够按照某种次序排列；三是es6创建了一种新的命令for of 循环，iterator接口主要供for  of消费

        // iterator的遍历过程是这样的
        // - 创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象的本质就是一个指针对象
        // - 第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员
        // - 第二次调用指针对象的next方法，可以将指针指向数据结构的第二个成员
        // - 第三次


        // 怎么手写一个promise
        // 01 promise的基本结构
    </script>
</body>

</html>